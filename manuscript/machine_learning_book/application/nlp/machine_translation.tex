\ifx\mlbook\undefined
    \documentclass[10pt,a4paper]{ctexbook}
    \providecommand{\pathroot}{../..}

    \usepackage[CJKbookmarks,colorlinks,linkcolor=red]{hyperref}
    \usepackage{geometry}
    \usepackage{amsmath}


    \geometry{left=3.0cm,right=3.0cm,top=2.5cm,bottom=2.5cm}
    \setmainfont{SimSun}
    \XeTeXlinebreaklocale "zh"
    \XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt

    \begin{document}
    \setlength{\baselineskip}{20pt}
    \title{机器翻译}
    \author{Donald Cheung\\jianzhang9102@gmail.com}
    \date{Nov 9, 2017}
    \maketitle
    \tableofcontents
\fi

\chapter{机器翻译}


\section{百度}
架构图：

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.3]{\pathroot/application/nlp/images/image2017-11-815_15_58.png}
    \includegraphics[scale=0.3]{\pathroot/application/nlp/images/image2017-11-817_8_40.png}
    \caption{机器翻译架构}
    \label{fig:baidu-mt-arch}
\end{figure}

\subsection{机器翻译架构简介}
\subsubsection{机器翻译模块}

\begin{enumerate}
\item dispatcher：机器翻译调度层，对接前段业务，分段分句后分发Terminal进行翻译\\
当query包含的句子较少时，Dispatcher会随机调用下游一个Terminal执行翻译工作；当query中句子较多时，Dispatcher会将句子随机分发给多个Terminal并行翻译。

\item terminal：机器翻译服务层，按翻译方向和模型种类区分 \\
terminal与执行的翻译任务一一对应，即执行中英翻译的terminal只能执行中英翻译任务。任务执行过程中，加载.so, lib, conf等文件

\item classifier ：分类服务，根据query的属性分配合适的翻译系统

\item zookeeper：zk管理所有terminal的信息，按翻译方向组织，dispatcher监听zk上方向节点的变化并将该方向下的terminal信息变化同步到本地（通过配置usemeta，决定是否使用，也可以通过读取本地文件的方式获取terminal信息）\\
zk管理所有terminal的信息，按翻译方向组织，zk上有一个servicelist节点，dispatcher启动时会读这个节点中对应配置文件，然后获取terminal的服务ip的端口，如果serverlist上的内容变化，zk会有回调函数通知dispatcher更改。Terminal启动时会主动去zk上注册

\item redis：Redis是dispatcher和terminal公用的，缓存原始query的MD5等其他拼接信息 \\
dispatcher端key是标记“dis”和相应翻译方向from、to、原始query的MD5哈希以及翻译处理版本号（GET\_TRANS\_V2及其他）的拼接。 \\
terminal端key是相应翻译方向from、to、翻译处理版本号（GET\_TRANS、GET\_TRANS\_V2及其他）以及原始句子的哈希的拼接

\item mola词典：Mola是一个词典，只读不写，储存了一段文本到翻译结果的映射，如果query的长度小于conf文件中的配置（目前线上系统是220），且类型不是网页翻译，来源是bae，段落长度等于1，会调用mola，查询成功会更改翻译类型为单词，然后返回。

\item RUU -> 对应三中机型的GPU, K1200, K40, P4（后续准备添加的机型），通过配置完成机型的选择 \\
dispatcher下发数据时，具有相应的策略将待翻译的内容划分成不同长度的字句，通过配置，譬如en1\_zh1 7:45:200:300， 英中翻译 7~45个字数的子句选择K1200 terminal处理，45~200个字数的字句选择K40的terminal处理，200~300个字句选择P4的terminal处理

\item Pbmt -> 对应CPU机器，处理GPU处理子句之外，其他的子句
\end{enumerate}
 
  
\textbf{测试模块（最小调度单元）}
整体模块中query是从odp或阿拉丁下发，dispatch读数据会调用redisCache和classifier，最后调用若干terminal执行翻译，terminal中也是有若干线程调用分布式语言模型和分布式翻译模型进行具体翻译过程。
\begin{enumerate}
\item dispatcher 机器翻译调度层，对接前段业务，分段分句后分发Terminal进行翻译 （重点测试Terminal分发）
\item terminal 机器翻译服务层，按翻译方向和模型种类区分 （调用后，正常返回结果）
\item classifier 分类服务，根据query的属性分配合适的翻译系统（如基础短语（pbmt）、RNN）
\end{enumerate}

Long Disparcher和Short Dispatcher的区别  -> 分别对应长文本和短文本？ \\
对长短query进行分别部署，是为了避免超长的query引起大量其他的短query全部超时。如果简单合并，一旦来了一个超长query，将所有Terminal的待翻译队列占满，那么这时候过来的短query就会全部超时。


\ifx\mlbook\undefined
    \end{document}
\fi
